# Notes

- Functions in Haskell only take one parameter
- The space is the function application.
  - E.g. defining `max :: Ord a => a -> a -> a` is equivalent to defining it is `max :: Ord a => a -> (a -> a)`
  - Has the highest precedence.
  - Curried functions
- To partially apply minus, `(subtract a)` because `(-a)` is means just negative a.
- Running `divTen = (/10)` in GCHI throws an error as it returns a function of type `Factional a => a -> a` and functions aren't part of the `Show` typeclass, so haskell doesn't know how to print it.
- Arrow operator in right-associative.
- When writing a function, you can omit the type declaration and use GHCI to check what Haskell has inferred the type to be (presumably a beginning techinque).
- Due to Haskell's lazy evaluation, when mapping and filtering over a list several times, it will only ever be enumerated once
- Function application with a space is left-associative (`f a b c` = `(((f a) b) c)`) whereas with $ its right-associative (`f $ a $ b $ c` = `(f $ (a $ (b $ c)))`)
- Function application operator allows us to treat function application like any other function, e.g. mapping application over a list of functions: `map ($ 3) [(4+), (5*), (/6), (^3)]`
- Because function composition is right-associative, you can chain functions that you want to compose! E.g.
  - `map (\xs -> negate (sum (tail xs))) [[1..5], [3..6], [1..7]]`
  - Vs. `map (negate . sum . tail) [[1..5], [3..6], [1..7]]` etc
- Can use compose functions which take several parameters by evaluating them with parameters in the correct order. E.g.
  - `sum (replicate 5 (max 6.7. 8.9))` vs `sum . replicate 5 . max 6.7 $ 8.9`
  - `replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,1,7,8])))` vs `replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,1,7,8]` 
- Omitting a parameter because of currying in a function definition is called 'point free style'. E.g `sum xs = foldl (+) 0 xs` vs `sum = foldl (+) 0`
- Searching for functions, etc:
  - [Hoogle](https://www.haskell.org/hoogle/)
  - [HHL](https://downloads.haskell.org/~ghc/latest/docs/html/libraries/)
- `Maybe a` can either be `Nothing` or `Just a`. Its like a special kind of list that can only hold either 1 value or nothing; `elemIndex` returns a `Maybe Int` because the element you pass it may or may not exist in the list in question, whereas `elemIndices` returns a `[Int]`, which will be empty if the element is never found.
- `[1..10] \\ [1,3,5]` is equivalent to `delete 1 . delete 3 . delete 5 $ [1..10]`
- For list functions that take `Int` and return `Int` where it would have been more convenient to deal in `Num`, you can use their `generic*` counterparts. 
- There are also functions like `nubBy, deleteBy, unionBy`, etc which take an equality function rather than expect lists of elements that conform to `Eq`.
- `Data.Char` exports a datatype like `Ordering` but that defines categories that chars fall into: `GeneralCategory`. Use `generalCategory` to determine the category of a char.. e.g `map generalCategory "something"`
- `Data.Map`'s `fromList` creates a map from an association list. It discards duplicate keys.
- `Data.Map`'s `Map` type wants its keys to conform to `Ord` so that it can arrange them as a tree.
- Value constructors are functions, so you can map them, partially apply them, etc.
- The type ctor is before the `=` and value ctors are after `=`, possibly separated by `|`s - they are distinct.
- We can `read` parameterized types provided that the type is specified, e.g. `read "Just 'a'" :: Maybe Char`.. would not work with `.. :: Maybe a`
- `Nothing` < `Just a`, when comparing 2 `Just a`s, because `Maybe` derives from `Ord`, Haskell goes to comparing the actual `a` values.
- `:` is actually a contructor which takes a value and another list and returns a list.
- Type constructors are just functions which take types as parameters and produce concrete types.
- `when` looks like control flow, but its just a function which takes a bool value and an IO action and if the bool action is false, it returns an noop IO action, else it returns the other IO action!
- Because functions are lazy in Haskell (i.e. they represent sort of promises that will return when required), `getContents` might read a line into memory when required, so mapping over the results of a `getContents` IO action will actually force it to read the values!
  - `putStr $ map toUpper someContents` will cause 1 line to be read from stdin and printed to the screen, then when the EOF char is hit (ctrl-D) it will assume the input is done and try mapping the next one, etc.
- You can't implement custom `deriving` funcitonality. `deriving` behaviour for certain typeclasses such as `Show` and `Eq` is built in to the compiler.
  - See [here](https://stackoverflow.com/questions/3864647/how-does-deriving-work-in-haskell).
- Class constraints on:
  - Typeclass declarations are used to make a typeclass a subclass of some typeclass, i.e. for type `b` to be a `Num`, first it has to equatable, i.e. `Eq`. E.g. if `b` was the type `Int`, in order for `Int` to be an instance of `Num`, you have to be able to compare them.
  - Instance delcarations are used to denote a requirement for type variables of the type in question to be instances of a particular typeclass themselves, to qualify as instances of the typeclass. E.g. if you wanted to treat `Something b` as equatable it would have to be an instance of `Eq`. It can be an instance of `Eq` without imposing any constraints on `b`, however if you wanted to compare the value of the type variable, that also has to be `Eq`. So, depending on what you're
    doing with `b` in `instance Eq (Something b)`, you might have to add type constraints.
  - Poses an interesting question - can you have 2 implementations of `Eq` for a given type, one for types of `b` that aren't `Eq` and one for types that are?
